#!/usr/bin/env ruby

# Copyright 2020 Ismo Kärkkäinen
# Licensed under Universal Permissive License. See License.txt.

require 'optparse'
require 'json'

$MIN = 0
$MIN_GIVEN = false
$MAX = 1
$MAX_GIVEN = false
$RANGE = 1

parser = OptionParser.new do |opts|
  opts.summary_indent = '  '
  opts.summary_width = 24
  opts.banner = "Usage: generate-changes [options]"
  opts.separator ""
  opts.separator "Options:"
  opts.on('--minimum MIN', 'Default minimum for maps.') do |v|
    $MIN = v.to_f
    $MIN_GIVEN = true
  end
  opts.on('--maximum MAX', 'Default maximum for maps.') do |v|
    $MAX = v.to_f
    $MAX_GIVEN = true
  end
  opts.on('--range RANGE', 'Default range for maps.') { |v| $RANGE = v.to_f }
  opts.on('-h', '--help', 'Print this help and exit.') do
    STDOUT.puts opts
    exit 0
  end
end
parser.parse!

def check_map(order, field, default)
  if order.has_key? field
    unless order[field].is_a? Array
      STDERR.puts "Not an array: #{field}"
      exit 2
    end
    if order[field].size < 2
      STDERR.puts "#{field} minimum array length is 2."
      exit 2
    else
      order[field].each do |a|
        unless a.is_a? Array
          STDERR.puts "#{field} contains non-array element."
          exit 2
        end
        if a.size < 2
          STDERR.puts "#{field} minimum sub-array length is 2."
          exit 2
        end
        a.each do |v|
          unless v.is_a? Numeric
            STDERR.puts "Not a number in #{field}: #{v}"
            exit 2
          end
        end
      end
    end
  else
    order[field] = [ [ default, default ], [ default, default ] ]
  end
end

def check_input(order)
  [ 'radius', 'offset' ].each do |category|
    if order.has_key?("#{category}_min") and order.has_key?("#{category}_max")
      p = Proc.new do |x, y, r|
        v = value(x, y, order["#{category}_min"])
        v + (value(x, y, order["#{category}_max"]) - v) * r
      end
    elsif order.has_key?("#{category}_min") and order.has_key?("#{category}_range")
      p = Proc.new do |x, y, r|
        value(x, y, order["#{category}_min"]) + value(x, y, order["#{category}_range"]) * r
      end
    elsif order.has_key?("#{category}_range") and order.has_key?("#{category}_max")
      p = Proc.new do |x, y, r|
        value(x, y, order["#{category}_max"]) - value(x, y, order["#{category}_range"]) * r
      end
    elsif order.has_key?("#{category}_range")
      p = Proc.new do |x, y, r|
        $MIN + value(x, y, order["#{category}_range"]) * r
      end
    elsif order.has_key?("#{category}_min")
      p = Proc.new do |x, y, r|
        value(x, y, order["#{category}_min"]) + $RANGE * r
      end
    elsif order.has_key?("#{category}_max")
      p = Proc.new do |x, y, r|
        value(x, y, order["#{category}_max"]) - $RANGE * r
      end
    else
      if $MIN_GIVEN and $MAX_GIVEN
        p = Proc.new { |x, y, r| $MIN + ($MAX - $MIN) * r }
      elsif $MAX_GIVEN
        p = Proc.new { |x, y, r| $MAX - $RANGE * r }
      else
        p = Proc.new { |x, y, r| $MIN + $RANGE * r }
      end
    end
    order[category] = p
    check_map(order, "#{category}_min", $MIN)
    check_map(order, "#{category}_max", $MAX)
    check_map(order, "#{category}_range", $RANGE)
  end
end

def value(x, y, plane)
  y = y * (plane.size - 1)
  yidx = y.to_i
  y = y - yidx
  xx = x * (plane[yidx].size - 1)
  xidx = xx.to_i
  xx = xx - xidx
  a = plane[yidx][xidx]
  b = plane[yidx][xidx + 1]
  v = y * (xx * a + (1.0 - xx) * b)
  xx = x * (plane[yidx + 1].size - 1)
  xidx = xx.to_i
  xx = xx - xidx
  a = plane[yidx + 1][xidx]
  b = plane[yidx + 1][xidx + 1]
  return v + (1.0 - y) * (xx * a + (1.0 - xx) * b)
end

rnd = Random.new
while true
  begin
    line = STDIN.readline
    order = JSON.parse(line)
    check_input(order)
  rescue EOFError
    break
  rescue JSON::ParserError => e
    STDERR.puts "Error parsing JSON: #{e.to_s}"
    exit 1
  end
  count = order.fetch('count', nil)
  if count.nil?
    STDERR.puts 'Missing "count".'
    exit 1
  end
  seed = order.fetch('seed', nil)
  rnd = Random.new(seed) unless seed.nil?
  changes = []
  (0...count).each do |k|
    c = [ rnd.rand, rnd.rand ]
    c.push order['radius'].call(c[0], c[1], rnd.rand)
    c.push order['offset'].call(c[0], c[1], rnd.rand)
    changes.push c
  end
  STDOUT.puts JSON.generate({ 'changes' => changes })
end
